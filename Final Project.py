# -*- coding: utf-8 -*-
"""12_8_23 (1) (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yNuc0_SCUPXx2FLMe2QvckPBBiXWiMGT

# ENGR 1330 â€“ Computational Thinking and Data Science

## HVAC Energy Predictor Final Project - Background

About 25% to 50%  of the total energy consumption by residential buildings are taken by Heating Ventilation and Air Conditioning (HVAC) systems. Architectural design factors involving size, shape and orientation of buildings significantly affect the heating and cooling load. A systematic study on dependence of heating and cooling load on architectural features can lead to energy efficient home design.  


Before you begin, read the description of the dataset here: https://archive.ics.uci.edu/dataset/242/energy+efficiency

## Objective(s):

- Literature scan on HVAC systems and their efficiency
- Analyse an existing  database and build data models to predict the heating load and cooling load
- Build an interface to allow users to enter and return an estimated  and an assessment of the uncertainty in the estimate
- Build an interface to allow users to add observations to the underlying database, and automatically update the Data Model to incorporate the new observations

## Tasks:

**Literature Research:**
- Briefly describe the challenge of minimizing residential HVAC energy consumption
- Summarize the value of a data model in the context of the conventional approach to HVAC energy prediction

Some places to start are:

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9571769/

https://www.sciencedirect.com/science/article/pii/S1364032114007151
    
https://www.mdpi.com/1424-8220/20/22/6419



**Exploratory Data Analysis**
- Describe (in words) the database.
- Reformat as needed (column headings perhaps) the database for subsequent analysis.

**Model Building**
- Build 2 separate data models to estimate the heating load and the cooling load based on the appropriate architectural features given in your dataset
- Assess the model quality
- Build the input data interface for using the model
- Using your model determine projected heating load and cooling load for 3 possible feature combinations in the table below:

![image.png](attachment:image.png)


               
       
**Documentation**
- Training video on how to use your tool, and demonstrate the tool(s) as they are run
- Interim report (see deliverables below); this document must be rendered as a .pdf.
- Final ipynb file (see deliverables below)

## Deliverables:

#### Part 1 Interim Report (due Dec 1):
A report that briefly describes the project. Use the Interim Report Template in BlackBoard.  
- Break down each task into manageable subtasks and describe how you intend to solve the subtasks and how you will test each task. (Perhaps make a simple Gantt Chart) or list of meeting times.
- Address the responsibilities of each team member for tasks completed and tasks to be completed until the end of the semester. (Perhaps make explicit subtask assignments)  

#### Part 2 Final Report (due Dec 10):
- A well-documented JupyterLab (using a python kernel), use markdown cells and commenting for explanations and text.
- A how-to video demonstrating performance and description of problems that you were not able to solve and also talk about project management such as who did what. Active participation of every single group member is mandatory in the presentation.
- A final peer evaluation report, where each group member should rate the participation and contribution of the other members.

**Above items can reside in a single video; but structure the video into the two parts; use an obvious transition when moving from "how to ..." into the project management portion.**  Keep the total video length to less than 10 minutes; submit as an *unlisted* YouTube video, and just supply the link (someone on each team is likely to have a YouTube creator account).  Keep in mind a 10 minute video can approach 100MB file size before compression, so it won't upload to Blackboard and cannot be emailed.

**A command to ignore warnings.**
"""

import warnings
warnings.filterwarnings('ignore')

"""**Code to import all necessary libraries needed for this project.**"""

import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn import metrics

"""**Read the provided DataFrame and remove the column with N/A variables. Also included is the code to rename the columns of the DataFrame to their respective titles.**"""

energy = pd.read_csv("ENB2012data.csv")
energy.drop("Unnamed: 10", axis=1, inplace=True)

energy.rename(columns={"X1" : "Relative Compactness", "X2" : "Surface Area", "X3" : "Wall Area", "X4" : "Roof Area", "X5" : "Overall Height", "X6" : "Orientation", "X7" : "Glazing Area", "X8" : "Glazing Area Distribution", "Y1" : "Heating Load", "Y2" : "Cooling Load"}, inplace = True)

energy

"""**Display statistical and basic information about the DataFrame.**"""

energy.info()
energy.describe()

"""**Displays the heatmap for the correlation values in the DataFrame. Allows us to see what correlates with what mathematically.**"""

num_col = energy.select_dtypes(include=["float64", "int64"]) #Stole this code from my Assignment 8
corr = num_col.corr() #Modified code from lecture demo
sns.heatmap(corr, annot=True, cmap='Reds')
plt.title("Feature Correlation Heatmap")

"""**Seaborn pairplot that displays all possible combinations of graphs. Allows us to see correlation visually to choose what features change heating/cooling load the most.**"""

sns.pairplot(energy)

"""**Narrow the DataFrame columns to only the features we are using and the results we are checking.**"""

data = energy.copy()
data = energy[["Relative Compactness", "Surface Area", "Wall Area", "Heating Load", "Cooling Load"]]
data.head()
data.describe()

"""**Getting the standard unit values for all columns being used.**"""

data['Relative Compactness (standard units)'] = (data['Relative Compactness'] - np.mean(data['Relative Compactness']))/(np.std(data['Relative Compactness']))
data['Surface Area (standard units)'] = (data['Surface Area'] - np.mean(data['Surface Area']))/(np.std(data['Surface Area']))
data['Wall Area (standard units)'] = (data['Wall Area'] - np.mean(data['Wall Area']))/(np.std(data['Wall Area']))
data['Heating Load (standard units)'] = (data['Heating Load'] - np.mean(data['Heating Load']))/(np.std(data['Heating Load']))
data['Cooling Load (standard units)'] = (data['Cooling Load'] - np.mean(data['Cooling Load']))/(np.std(data['Cooling Load']))
data.head()

"""## Heating Load Simulation

**Specify what features will be applied to what constant.**
"""

x = energy[["Relative Compactness", "Surface Area", "Wall Area"]]
y = energy["Heating Load"]

"""**Train-test split**"""

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.333333)

lm = LinearRegression()
lm.fit(x_train,y_train)

print(lm.coef_)
print(lm.intercept_)

"""**Apply Polynomial Regression for train and test set.**"""

poly = PolynomialFeatures(degree=4)
x_train_poly = poly.fit_transform(x_train)
x_test_poly = poly.fit_transform(x_test)

pol_reg = LinearRegression()
pol_train = pol_reg.fit(x_train_poly, y_train)
pol_test = pol_reg.fit(x_test_poly, y_test)

y_train_pred_poly = pol_reg.predict(x_train_poly)

sorted_indices = np.argsort(y_train)
y_train_sorted = y_train.iloc[sorted_indices]
y_train_pred_poly_sorted = y_train_pred_poly[sorted_indices]

plt.scatter(y_train, y_train_pred_poly, label='Actual vs. Predicted')
plt.plot(y_train_sorted, y_train_pred_poly_sorted, color='r', lw=1, label='Best Fit Curve')
plt.xlabel("Train Heating Load")
plt.ylabel("Train heating Load Prediction")
plt.title("Prediction vs. Acutal Train Heating Load (Polynomial)")
plt.show()

y_test_pred_poly = pol_reg.predict(x_test_poly)
y_test_pred = lm.predict(x_test)

sorted_indices = np.argsort(y_test)
y_test_sorted = y_train.iloc[sorted_indices]
y_test_pred_poly_sorted = y_test_pred_poly[sorted_indices]

plt.scatter(y_test, y_test_pred_poly, label='Actual vs. Predicted')
plt.plot([y_test.min(), y_test.max()], [y_test_pred.min(), y_test_pred.max()], color = 'r', lw=2)
plt.xlabel("Test Heating Load")
plt.ylabel("Test heating Load Prediction")
plt.title("Prediction vs. Acutal Test Heating Load (Polynomial)")
plt.show()

"""**Compare to Linear Regression of test set.**"""

y_test_pred = lm.predict(x_test)

plt.scatter(y_test,y_test_pred,color='r')
plt.plot([y_test.min(), y_test.max()], [y_test_pred.min(), y_test_pred.max()], color = 'black', lw=2)
plt.xlabel("Test Heating Load")
plt.ylabel("Test heating Load Prediction")
plt.title("Prediction vs. Acutal Test Heating Load (Linear)")
plt.show()

y_train_pred = lm.predict(x_train)

plt.scatter(y_train,y_train_pred,color='r')
plt.plot([y_train.min(), y_train.max()], [y_train_pred.min(), y_train_pred.max()], color = 'black', lw=2)
plt.xlabel("train Heating Load")
plt.ylabel("Train heating Load Prediction")
plt.title("Prediction vs. Acutal Train Heating Load (Linear)")
plt.show()

"""**Calculate MSE and RMSE values for train and test sets.**"""

MSE_train_lin = metrics.mean_squared_error(y_train, y_train_pred)
RMSE_train_lin = np.sqrt(MSE_train_lin)

MSE_train_poly = metrics.mean_squared_error(y_train, y_train_pred_poly)
RMSE_train_poly = np.sqrt(MSE_train_poly)

print("MSE value from Linear Regression:", MSE_train_lin)
print("MSE value from Polynomial Regression:", MSE_train_poly)

print("RMSE value from Linear Regression:", RMSE_train_lin)
print("RMSE value from Polynomial Regression:", RMSE_train_poly)

MSE_test_lin = metrics.mean_squared_error(y_test, y_test_pred)
RMSE_test_lin = np.sqrt(MSE_test_lin)

MSE_test_poly = metrics.mean_squared_error(y_test, y_test_pred_poly)
RMSE_test_poly = np.sqrt(MSE_test_poly)

print("MSE value from Linear Regression:", MSE_test_lin)
print("MSE value from Polynomial Regression:", MSE_test_poly)

print("RMSE value from Linear Regression:", RMSE_test_lin)
print("RMSE value from Polynomial Regression:", RMSE_test_poly)

"""## Cooling Load Simulation"""

x = energy[["Relative Compactness", "Surface Area", "Wall Area"]]
y = energy["Cooling Load"]

"""**Train-test split**"""

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.333333)

lm = LinearRegression()
lm.fit(x_train,y_train)

print(lm.coef_)
print(lm.intercept_)

"""**Apply Polynomial Regression for train and test set.**"""

poly = PolynomialFeatures(degree=4)
x_train_poly = poly.fit_transform(x_train)
x_test_poly = poly.fit_transform(x_test)

pol_reg = LinearRegression()
pol_train = pol_reg.fit(x_train_poly, y_train)
pol_test = pol_reg.fit(x_test_poly, y_test)

y_train_pred_poly = pol_reg.predict(x_train_poly)

sorted_indices = np.argsort(y_train)
y_train_sorted = y_train.iloc[sorted_indices]
y_train_pred_poly_sorted = y_train_pred_poly[sorted_indices]

plt.scatter(y_train, y_train_pred_poly, label='Actual vs. Predicted')
plt.plot(y_train_sorted, y_train_pred_poly_sorted, color='r', lw=1, label='Best Fit Curve')
plt.xlabel("Train Cooling Load")
plt.ylabel("Train Cooling Load Prediction")
plt.title("Prediction vs. Acutal Train Cooling Load (Polynomial)")
plt.show()

y_test_pred_poly = pol_reg.predict(x_test_poly)
y_test_pred = lm.predict(x_test)

sorted_indices = np.argsort(y_test)
y_test_sorted = y_train.iloc[sorted_indices]
y_test_pred_poly_sorted = y_test_pred_poly[sorted_indices]

plt.scatter(y_test, y_test_pred_poly, label='Actual vs. Predicted')
#plt.plot(y_test_pred_poly_sorted, y_test_sorted, color='r', lw=1, label='Best Fit Curve')
plt.plot(y_train_sorted, y_train_pred_poly_sorted, color='r', lw=1, label='Best Fit Curve')
plt.xlabel("Test Cooling Load")
plt.ylabel("Test Cooling Load Prediction")
plt.title("Prediction vs. Acutal Test Cooling Load (Polynomial)")
plt.show()

"""**Compare to Linear Regression of test set.**"""

y_test_pred = lm.predict(x_test)

plt.scatter(y_test,y_test_pred,color='r')
plt.plot([y_test.min(), y_test.max()], [y_test_pred.min(), y_test_pred.max()], color = 'black', lw=2)
plt.xlabel("Test Cooling Load")
plt.ylabel("Test Cooling Load Prediction")
plt.title("Prediction vs. Acutal Test Cooling Load (Linear)")
plt.show()

"""**Calculate MSE and RMSE values for train and test sets.**"""

MSE_train_lin = metrics.mean_squared_error(y_train, y_train_pred)
RMSE_train_lin = np.sqrt(MSE_train_lin)

MSE_train_poly = metrics.mean_squared_error(y_train, y_train_pred_poly)
RMSE_train_poly = np.sqrt(MSE_train_poly)

print("MSE value from Linear Regression:", MSE_train_lin)
print("MSE value from Polynomial Regression:", MSE_train_poly)

print("RMSE value from Linear Regression:", RMSE_train_lin)
print("RMSE value from Polynomial Regression:", RMSE_train_poly)

MSE_test_lin = metrics.mean_squared_error(y_test, y_test_pred)
RMSE_test_lin = np.sqrt(MSE_test_lin)

MSE_test_poly = metrics.mean_squared_error(y_test, y_test_pred_poly)
RMSE_test_poly = np.sqrt(MSE_test_poly)

print("MSE value from Linear Regression:", MSE_test_lin)
print("MSE value from Polynomial Regression:", MSE_test_poly)

print("RMSE value from Linear Regression:", RMSE_test_lin)
print("RMSE value from Polynomial Regression:", RMSE_test_poly)

